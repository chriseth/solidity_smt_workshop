\section{SMT-based Solidity verification}
\label{section:smt}

SMT solvers are powerful tools to prove satisfiability of formulas in different
logics which often have the necessary expressiveness to model software in a
straightforward manner~\cite{Komuravelli13,Alt17,Donaldson11,Beyer11}.

We translate Solidity contracts and their functions into SMT formulas using a
combination of different quantifier-free theories.
%
We shall name the translated formulas the \emph{SMT encoding} of the Solidity
program.
%
The goal of the translation from Solidity to SMT formulas is to verify safety
properties from the Solidity program by performing queries to the SMT solver.

\subsection{SMT encoding}

The SMT encoding is computed in a top-down way traversing the AST of the
Solidity program and roughly following the execution order.
%
The context regarding the SMT solver, contract storage, and local variables of
functions is cleared before each function of a contract is visited.
%
There are four types of encoding from Solidity inside each function.
%
Three of them, \emph{Control-flow}, \emph{Type constraint} and \emph{Variable assignment}
are simply translated as SMT constraints.
%
The last, \emph{Verification Target}, creates a formula consisting of the
verification goal conjoined with the previously mentioned constraints, and
queries the SMT solver for satisfiability.
%
The different types of encoding are described below.

\begin{paragraph}{Control-flow.}
Because the Solidity code is visited via its AST, we can maintain a stack of
conditions that need to be true if and only if control flow reaches the piece
of code currently being encoded: whenever an \emph{if-statement} is visited,
its condition is pushed onto the stack, the branch's body is encoded and the
condition is popped again.
%
Similarly, the negation of the condition is pushed onto the stack when visiting
an \emph{else} branch, and popped afterwards.
\end{paragraph}

\begin{paragraph}{Type constraint.}
A variable declaration leads to a correspondent SMT variable that is assigned
the default value of the declared type.
%
For example, Boolean variables are assigned false, and integer variables are
assigned 0.
%
Function parameters are initialized with a range of valid values for the given
type, since their value is unknown.  For instance, a parameter \code{uint32 x}
is initialized as $0 \le x < 2^{32}$ (32 bits), and a parameter \code{address
a} is assigned the range $0 \le a < 2^{(8*20)}$ (20 bytes).
%
The encoder currently supports Boolean and the various sizes of Integer
variables.

\end{paragraph}

\begin{paragraph}{Variable assignment.}
The encoding of variable assignment follows the \emph{Single Static Assignment}
(SSA) where each assignment to a program variable introduces a new SMT variable
that is assigned to only once.
%
When a program variable is modified at a place that is executed only
conditionally (if-else), the \emph{if-then-else} operator (ite) is used as the
common SSA $\phi$ function associated with the branch condition to create a new
SMT variable after the branch blocks.
\end{paragraph}

\begin{paragraph}{Verification target.}
Every arithmetic operation is checked against underflow and overflow according
to the type of the values, and an example is given if there is an underflow or
overflow.
%
We also check whether branch conditions are constant, warning the user about
unreachable blocks or trivial conditions.
%
The conditions in calls to \code{assert} represent target postconditions that the
Solidity programmer wants to ensure at runtime and are verified statically.
%
If it is possible to disprove the assertion, the user is given a
counterexample.
%
In contrast, \code{require} conditions are meant to be used as
filters for unwanted input values when they are unknown, for example, in public
functions.
%
Therefore they act like preconditions for the rest of the scope, implied by the
conjunction of the conditions from the conditions stack.
%
Failing calls to \code{require} are not treated as errors and
are just checked for triviality and reachability.
\end{paragraph}

Figure~\ref{figure:solidity_encoding_1} shows on the left a Solidity sample
that requires all four types of encoding, shown on the right, in order to
erify the intended properties.
%
Since the variables \code{uint256 a} and \code{uint256 b} are function
parameters, they are initialized (lines 1 and 2) with the valid range of values
for their type (\code{uint256}).
%
If \code{a = 0}, the \code{require} condition about \code{b} is used as a
precondition when verifying the assertion in the end of the function (line 3).
%
The next two assignments to \code{b} create the new SSA variables
$b_1$ and $b_2$ (line 4).
%
Variable $b_3$ encodes the second and third conditions, and $b_4$
encodes the first condition (lines 5 and 6).
%
Finally, $b_4$ is used in the assertion check (line 7).
%
Note that the nested control-flow is implicitly encoded in the $ite$
variables $b_3$ and $b_4$.
%
We can see that the target assertion is safe within its function.

\begin{figure}
\label{figure:solidity_encoding_1}
\noindent\begin{minipage}{.48\textwidth}
\begin{verbatim}
contract C
{
  function f(uint256 a, uint256 b)
  {
    if (a == 0)
      require(b <= 100);
    else if (a == 1)
      b = 1000;
    else
      b = 10000;
    assert(b <= 100000);
  }
}
\end{verbatim}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
1. $a_0 \ge 0 \land a_0 < 2^{256}  \land \phantom{x}$\\
2. $b_0 \ge 0 \land b_0 < 2^{256}  \land \phantom{x}$\\
3. $(a_0 = 0) \rightarrow (b_0 \le 100) \, \land$\\
4. $b_1 = 1000 \land b_2 = 10000$\\
5. $b_3 = ite(a == 1, b_1, b_2) \land \phantom{x}$\\
6. $b_4 = ite(a == 0, b_0, b_3) \land \phantom{x}$\\
7. $\neg b_4 \le 100000$
\end{minipage}
\caption{SMT encoding of an assertion check.}
\end{figure}

It is important to highlight that errors are irrelevant if they result in a
state change reversion (Sec.~\ref{section:smart_contracts}). The user is warned
about checks such as overflow only if they do not result in a state reversion.
%
One popular example is the SafeMath~\cite{SafeMath} contract which
is commonly used to turn wrapping arithmetics into overflow-checked arithmetics:

\begin{verbatim}
  function add(uint256 a, uint256 b) internal pure
        returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
\end{verbatim}

Although the tool detects an overflow in the computation of \code{a + b},
the overflow will result in a truncation of \code{c} in two's complement and thus
any execution that contains the overflow will revert at the \code{require}.
%
In this case the user is not warned of the error, since no erroneous cases
exist in accepted executions.

As described above, the component performs several local checks during a single
run, therefore it is critical that the used SMT solver supports
incremental checking.
%
Moreover, we do not abstract difficult operations such as multiplication
between variables, rather trying to give precise answers when possible.
%
Therefore we combine various quantifier-free theories, such as Linear
Arithmetics, Uninterpreted Functions and Nonlinear Arithmetics. 
%
Solidity has integrated Z3~\cite{Z3} and CVC4~\cite{CVC4} via their C++ APIs.
%
The two SMT solvers are used together to increase solving power.
%
This has been important especially for the programs that require Nonlinear
reasoning, since often one solver is able to prove a property that the other
cannot.
%
The component is also able to generate \code{smtlib2}~\cite{SMTLIB}
formulas in order to interface with additional solvers.


\subsection{Future plans}

Our current implementation plans for the component involve supporting
a larger subset of the language, including more complex data structures
such as \code{mapping}.
%
We intend to build the component as a Bounded Model Checker, unrolling loops
up to a constant bound and automatically detecting bounds when possible.
%
This feature is currently being implemented.

One of the most interesting aspects we intend to research and support is
multi-transaction invariants.
%
The ultimate goal is to compute invariants for state variables (resident in the
contract's storage) considering any arbitrary number of calls to the contract.
%
This would enable these invariants to be used as preconditions whenever they
are accessed.
%
As an example, take contract \code{Token} from Sec.~\ref{section:solidity}.
%
We can see from the constructor that the deployer of the contract receives
10000 tokens.
%
The only way to move tokens is via function \code{transfer}, which decreases a
certain amount of tokens from one account, if it owns enough, and increases the
same amount in another account.
%
As we can see, the number of total tokens never changes and the invariant
$\sum_{a \in balances} balances[a] = 10000$ \todo{fix this, looks ugly} holds
in the beginning of any function of the contract.

\todo{Modifiers}

The idea of \emph{Effective Callback Freeness} was recently introduced by
\cite{Grossman}.
%
A smart contract $C$ is free of callbacks if any external call to another
contract cannot eventually affect $C's$ storage.
%
The authors show that most of the contracts deployed on Ethereum have this
property.
%
This is a powerful property, since it means that any invariant computed for a
contract's state variables still holds even after calling external contracts
with unknown behavior.
%
We intend to study how to integrate this approach to our static analysis.
