\section{SMT-based Solidity verification}
\label{section:smt}

SMT solvers are powerful tools to prove satisfiability of formulas in different
logics which often have the necessary expressiveness to model software in a
straightforward manner~\cite{Komuravelli13,Alt17,Donaldson11,Beyer11}.

We translate Solidity contracts and their functions into SMT formulas using a
combination of different quantifier-free theories.
%
We shall name the translated formulas the \emph{SMT encoding} of the Solidity
program.
%
The goal of the translation from Solidity to SMT formulas is to verify safety
properties from the Solidity program by performing queries to the SMT solver.

\todo{the transition from the previous section to
this one is a little rough. Why do we SMT-encode and what
do we encode? ; L: added text above}

\subsection{SMT encoding}

The SMT encoding is computed in a top-down way traversing the AST of the
Solidity program and roughly following the execution order.
The context regarding the SMT solver, contract storage, and
local variables of functions is cleared before each function of a contract is
visited.

Inside each function, a variable declaration leads to a correspondent SMT
variable that is assigned the default value of the declared type.
%
Function parameters are initialized with a range of valid values for the given
type, since their value is unknown.  For instance, a parameter \code{uint32 x}
is initialized as $0 \le x < 2^{32}$ (32 bits), and a parameter \code{address
a} is assigned the range $0 \le a < 2^{(8*20)}$ (20 bytes).
%
The encoding of variable assignment follows the \emph{Single Static Assignment}
(SSA) where each assignment to a program variable introduces a new SMT variable
that is assigned to only once.
%
The encoder currenty supports \emph{Bool} and the various sizes of
\emph{Integer} variables.

Because the Solidity code is visited via its AST, we can maintain a stack of
conditions that need to be true if and only if control flow
reaches the piece of code currently being encoded: whenever an
\emph{if-statement} is visited, its condition is pushed onto the stack, the
branch's body is encoded and the condition is popped again.
%
Similarly, the negation of the condition is pushed onto the stack when visiting
an \emph{else} branch, and popped afterwards.
%
Control flow is then encoded using the \emph{if-then-else} operator (ite) as
the SSA $\phi$ function, with the head of the stack as the condition of the
if-then-else expression.

Every arithmetic operation is checked against underflow and overflow according
to the type of the values, and an example is given if there is an underflow or
overflow.
%
We also check whether branch conditions are constant, warning the user about
unreachable blocks or trivial conditions.
%
The conditions in calls to \code{assert} represent target postconditions that the
Solidity programmer wants to ensure at runtime and are verified statically.
%
If it is possible to disprove the assertion, the user is given a
counterexample.
%
In contrast, \code{require} conditions are meant to be used as
filters for unwanted input values when they are unknown, for example, in public
functions.
%
Therefore they act like preconditions for the rest of the scope, implied by the
conjunction of the conditions from the conditions stack.
%
Failing calls to \code{require} are not treated as errors and
are just checked for triviality and reachability.
%

Figure~\ref{figure:solidity_encoding_1} shows a Solidity sample and its SMT
encoding with emphasis on the control flow handling while verifying an assertion.
%
Since the variables \code{uint256 a} and \code{uint256 b} are function parameters, they
are initialized with the valid range of values for their type (\code{uint256}).
%
If \code{a = 0}, the \code{require} condition about \code{b} is used as a
precondition when verifying the assertion in the end of the function.
\todo{C: I do
not understand this; L: maybe better now?}.
%
The next two assignments to \code{b} create the new SSA variables
$b_1$ and $b_2$.
%
Variable $b_3$ encodes the second and third conditions, and $b_4$
encodes the first condition.
%
Finally, $b_4$ is used in the assertion check.
%
Note that the nested control-flow is implicitly encoded in the $ite$
variables $b_3$ and $b_4$.
%
We can see that the target assertion is safe within its function.

\begin{figure}
\label{figure:solidity_encoding_1}
\noindent\begin{minipage}{.48\textwidth}
\begin{verbatim}
contract C
{
  function f(uint256 a, uint256 b)
  {
    if (a == 0)
      require(b <= 100);
    else if (a == 1)
      b = 1000;
    else
      b = 10000;
    assert(b <= 100000);
  }
}
\end{verbatim}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
$a_0 \ge 0 \land a_0 < 2^{256}  \land \phantom{x}$\\
$b_0 \ge 0 \land b_0 < 2^{256}  \land \phantom{x}$\\
$(a_0 = 0) \rightarrow (b_0 \le 100) \, \land$\\
$b_1 = 1000 \land b_2 = 10000$\\
$b_3 = ite(a == 1, b_1, b_2) \land \phantom{x}$\\
$b_4 = ite(a == 0, b_0, b_3) \land \phantom{x}$\\
$\neg b_4 \le 100000$
\end{minipage}
\caption{SMT encoding of an assertion check highlighting control-flow.}
\end{figure}

It is important to highlight that errors are irrelevant if they result in a
state reversion (Sec.~\ref{section:smart_contracts}). The user is warned
about checks such as overflow only if they do not result in a state reversion.
%
One popular example is the SafeMath~\cite{SafeMath} contract:

\begin{verbatim}
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
\end{verbatim}

Although the tool sees an overflow in the computation of \code{a + b}, since
both have type \code{uint256} which is the largest integer, any execution that
containts the overflow reverts due to the \code{assert}.
%
In this case the user is not warned of the error, since no erroneous cases
exist in accepted executions.

As described above, the component performs several local checks during a single
run, therefore it is critical that the used SMT solver has support to
incremental checking.
%
Moreover, we do not abstract difficult operations such as multiplication
between variables, rather trying to give precise answers when possible.
%
Therefore we combine various quantifier-free theories, such as Linear
Arithmetics, Uninterpreted Functions and Nonlinear Arithmetics. 
%
Solidity has integrated Z3~\cite{Z3} and CVC4~\cite{CVC4} via their C++ APIs.
%
The two SMT solvers are used together to increase solving power.
%
This has been important especially for the programs that require Nonlinear
reasoning, since often one solver is able to prove a property that the other
cannot.
%
In case both Z3 and CVC4's APIs are not available but binaries are, the
component generates \code{smtlib2}~\cite{SMTLIB} formulas and invokes the
solver binaries.


\subsection{Future plans}

Our current implementation plans for the component involve supporting
a larger subset of the language, including more complex data structures
such as \code{mapping}.
%
We intend to build the component as a Bounded Model Checker, unrolling loops
up to a constant bound and automatically detecting bounds when possible.
%
This feature is currently being implemented.

One of the most interesting aspects we intend to research and support is
multi-transaction invariants.
%
The ultimate goal is to compute invariants for state variables (resident in the
contract's storage) considering any arbitrary number of calls to the contract.
%
This would enable these invariants to be used as preconditions whenever they
are accessed.
%
As an example, take contract \code{Token} from Sec.~\ref{section:solidity}.
%
We can see from the constructor that the deployer of the contract receives
10000 tokens.
%
The only way to move tokens is via function \code{transfer}, which decreases a
certain amount of tokens from one account, if it owns enough, and increases the
same amount in another account.
%
As we can see, the number of total tokens never changes and the invariant
$\sum_{a \in balances} balances[a] = 10000$ holds in the beginning of any
function of the contract.

The idea of \emph{Effective Callback Freeness} was recently introduced by
\cite{Grossman}.
%
A smart contract $C$ is free of callbacks if any external call to another
contract cannot eventually affect $C's$ storage.
%
The authors show that most of the contracts deployed on Ethereum have this
property.
%
This is a powerful property, since it means that any invariant computed for a
contract's state variables still holds even after calling external contracts
with unknown behavior.
%
We intend to study how to integrate this approch to our static analysis.
