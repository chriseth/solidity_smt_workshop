\section{Smart Contracts}
\label{section:smart_contracts}

%Due to space constraints, we will only give a very brief description
%of smart contracts on Ethereum and leave out some details.

Programs in Ethereum are called \emph{smart contracts}.
Each smart contract is stored at its \emph{address} with its \emph{code}
and a key-value store of data (\emph{storage}). The code is fixed after the creation phase
and only the smart contract itself can modify the data stored at its address.

Users can interact with a smart contract by sending a \emph{transaction}
to its address. This causes the smart contract's code to execute inside
the so-called \emph{Ethereum Virtual Machine} (EVM), which is a stack-based
256-bit machine with a minimalistic instruction set. Each execution environment
has a freshly initialized \emph{memory area} (not to be confused with the persisting
storage). During its execution, a smart contract can also call other
smart contracts synchronously, which causes their code to be run in
a new execution environment. Data can be passed and received in calls.
Furthermore, smart contracts can also create new smart contracts with
arbitrary code.

Since it would otherwise be easy to stall the network by asking it to
execute a complex task, the resources consumed are metered during execution
in a unit called \emph{gas}. Each transaction only provides a certain
amount of gas, and as soon as this \emph{gas limit} is reached without
prior termination, any effect of the transaction is reverted.
In every case, the user
who requested the execution pays for it with Ethereum's native token
Ether proportionally to the amount of gas consumed.

A reverting termination can also happen prior to all gas being consumed. This is
a special feature of the Ethereum Virtual Machine,
which makes the control-flow analysis different from other languages.
Whenever the EVM encounters an invalid situation (invalid opcode, invalid
stack access, etc.), execution will not only stop, but all effects on the
state will be reverted. This reversion takes effect in the current execution
environment, and the environment will also
flag a failure to the calling environment, if present. Typically, high level languages
will cause an invalid situation whenever a call fails and thus the reversion
affects the whole transaction.

There is also an explicit opcode that causes the current call to fail, which is
essentially the same as described above, but as an intended effect.

\todo{Talk about ``all paths that fail eventually revert"}

Very briefly, the SMT encoding assumes that no intended failure happens
and tries to deduct that no unintended failure can occur. This allows the
programmer to state preconditions using intended failures and postconditions
using unintended failures.
